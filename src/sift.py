import numpy as np
import cv2
import utils.plt_utils as plt_utils
import matplotlib.pyplot as plt
import utils.file_io_utils as io
from process_image_background import undistort, get_undistored_k_matrix, get_ordered_image_points
import utils.linalg_utils as linalg
from collections import namedtuple

class SIFTFeature:
    '''
    @brief  Class to pack required information for SIFT features
    '''
    def __init__(self, image_idx, coordinates, descriptor):
        self.image_idx = image_idx
        self.coordinates = coordinates
        self.descriptor = descriptor

# namedtyple to describe the limited search window
Window = namedtuple("Window", "xmin xmax ymin ymax")

def draw_key_points(image, detailed=True, savefile=None):
    '''
    @brief  Draws the found keypoints on top of the image

    @param image        The original image
    @param detailed     Whether or not to draw keypoints based on relative 
                        scale
    @param savefile     Save location for resulting images. Does not save if 
                        None
    @return             The newly generated image containing the drawn keypoints
    '''
    sift = cv2.SIFT_create()

    if len(image.shape) > 2:
        im_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        im_gray = image

    kp = sift.detect(image,None)
    
    if detailed:
        im_kp=cv2.drawKeypoints(im_gray, kp, image, flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    else:
        im_kp=cv2.drawKeypoints(im_gray, kp, image)

    if savefile:
        cv2.imwrite(savefile, im_kp)
    
    return im_kp

def find_window_of_interest(image_points):
    '''
    @brief  Generates the window of interest from x-corner locations

    @param image_points     The sorted locations of the x-corners in the image
    @return                 A limited search window within the image. Window 
                            is a namedtuple defined above
    '''
    x_vals, y_vals = zip(*image_points)
    
    # coordinates of inner corners
    x_vals = x_vals[2:16:4]
    y_vals = y_vals[2:16:4]

    return Window(min(x_vals), max(x_vals), min(y_vals), max(y_vals))

def kp_in_bound(kp, window):
    '''
    @brief  Computes whether the keypoint is located in the window

    @param kp       The keypoint object generated by SIFT
    @param window   A limited search window within the image. Window is a 
                    namedtuple defined above
    @return         True if the keypoint is within the window, False otherwise
    '''
    coords = kp.pt

    x_in_range = window.xmin < coords[0] < window.xmax
    y_in_range = window.ymin < coords[1] < window.ymax

    return x_in_range and y_in_range

def get_sift_feature_objects(image, image_index, window):
    '''
    @brief  Generates a list of SIFTFeature objects representing features 
            found in the image

    @param image        The image used for the feature search
    @param image_index  The index of the image for which the features are 
                        found. This helps keep track of which image the 
                        feature belongs to
    @param window       A limited search window within the image. Window is a 
                        namedtuple defined above
    @return             A list of SIFTFeature objects representing image 
                        features
    '''
    sift = cv2.SIFT_create()
    kps, descs = sift.detectAndCompute(image, None)

    feature_list =  [
        SIFTFeature(image_index, kp.pt, des)
        for (kp, des) in zip(kps, descs)
        if kp_in_bound(kp, window)
    ]

    return feature_list

def find_match(feature, feature_list, ratio_threshold=0.7):
    '''
    @brief  Find the best match for feature in feature_list. Indicates if the 
            match is valid

    @param feature          The feature to be matched
    @param feature_list     A list of potential matches
    @param ratio_threshold  The maximum allowable ratio between the nearest 
                            neighbour descriptor distance and second nearest 
                            neighbour descriptor distance for the match to be 
                            kept. Recommended values beteween 0.6 and 0.8
    @return is_valid        A flag indicating whether the match is valid
    @return best            The best feature match from feature_list
    '''
    for potential_match in feature_list:
        if potential_match.image_idx != feature_list[0].image_idx:
            raise ValueError("Features must be from the same image")

    # copy list to not change it
    potential_matches = feature_list[:]

    # sort index list based on distance
    potential_matches.sort(
        key=lambda potential_match: linalg.get_euclidean_distance(feature.descriptor, potential_match.descriptor)
    )

    best, second_best = potential_matches[:2]
    
    # check if match is valid
    min_dist = linalg.get_euclidean_distance(best.descriptor, feature.descriptor)
    next_dist = linalg.get_euclidean_distance(second_best.descriptor, feature.descriptor)
    valid_match = min_dist / next_dist < ratio_threshold

    return (valid_match, best)

def find_match_group(feature, feature_lists, ratio_threshold=0.7):
    match_tuples = [
        find_match(feature, feature_list, ratio_threshold=ratio_threshold)
        for feature_list in feature_lists
        if len(feature_list) > 1
    ]

    # add current feature as a valid feature in the group
    match_tuples.append((True, feature))

    return tuple(
        match_tuple[1]
        for match_tuple in match_tuples
        if match_tuple[0]
    )

def group_feature_matches(feature_lists, ratio_threshold=0.7):
    '''
    @brief  Generates a list containing groups of features that were matched 
            across the images

    @param feature_lists    A list of length equalling the number of images, 
                            with each element containing the features detected 
                            for the image
    @param ratio_threshold  The maximum allowable ratio between the nearest 
                            neighbour descriptor distance and second nearest 
                            neighbour descriptor distance for the match to be 
                            kept. Recommended values beteween 0.6 and 0.8
    @return                 a list containing lists of matching features
    '''
    feature_groups = []
    num_lists = len(feature_lists)
    for i in range(num_lists):
        for feature in feature_lists[i]:
            # Skip feature matching if feature already matched
            already_matched = any(
                feature in group
                for group in feature_groups
            )

            if already_matched:
                continue

            # first, get all feature lists except current one
            other_lists = [
                feature_lists[j]
                for j in range(num_lists)
                if j != i
            ]

            # get all matches to current feature
            group = find_match_group(feature, other_lists, ratio_threshold=ratio_threshold)

            # skip group if it only contains current feature
            if len(group) == 1:
                continue


            # append group to group list
            feature_groups.append(group)

    return feature_groups